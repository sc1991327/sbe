#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/core/core.hpp>

#include <iostream>  
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <math.h>
#include <direct.h>
#include <fstream>
#include "ml.h"
#include <utility>
#include <list>
#include <io.h>

#include "OpticalFlow.h"

using namespace std;
using namespace cv;

#define UNKNOWN_FLOW_THRESH 1e9

OpticalFlow::OpticalFlow(){



}

OpticalFlow::~OpticalFlow(){



}

// return optical data.
Mat OpticalFlow::getOpticalFlow(Mat img, Mat img_pre){

	return calcOpticalFlow(img, img_pre);

}

Mat OpticalFlow::getOpticalFlowX(Mat img, Mat img_pre){

	// get optical flow result data.
	Mat ofdata = calcOpticalFlow(img, img_pre);

	// create output mat
	Mat ofout;
	ofout.create(ofdata.rows, ofdata.cols, CV_32FC1);
	
	// get data
	for (int i = 0; i < ofdata.rows; ++i)
	{
		for (int j = 0; j < ofdata.cols; ++j)
		{
			Vec2f flow_at_point = ofdata.at<Vec2f>(i, j);
			float fx = flow_at_point[0];
			ofout.at<float>(i, j) = fx;
		}
	}
	normalize(ofout, ofout, 0, 255, NORM_MINMAX, CV_8UC1);

	return ofout;

}

Mat OpticalFlow::getOpticalFlowY(Mat img, Mat img_pre){

	// get optical flow result data.
	Mat ofdata = calcOpticalFlow(img, img_pre);

	// create output mat
	Mat ofout;
	ofout.create(ofdata.rows, ofdata.cols, CV_32FC1);

	// get data
	for (int i = 0; i < ofdata.rows; ++i)
	{
		for (int j = 0; j < ofdata.cols; ++j)
		{
			Vec2f flow_at_point = ofdata.at<Vec2f>(i, j);
			float fy = flow_at_point[1];
			ofout.at<float>(i, j) = fy;
		}
	}
	normalize(ofout, ofout, 0, 255, NORM_MINMAX, CV_8UC1);

	return ofout;

}

// return color marked optical flow image.
// Can imshow directly.
Mat OpticalFlow::showOpticalFlow(Mat img, Mat img_pre){

	Mat flow = calcOpticalFlow(img, img_pre);
	Mat motion2color;
	motionToColor(flow, motion2color);

	return motion2color;
}

// -----------------------------------------------------------------------
// inner methods

// input RGB images
Mat OpticalFlow::calcOpticalFlow(Mat img, Mat img_pre){

	//prepare parameters
	Mat imgA, imgB;
	cvtColor(img_pre, imgA, CV_BGR2GRAY);
	cvtColor(img, imgB, CV_BGR2GRAY);

	//calculate change
	Mat flow;
	calcOpticalFlowFarneback(imgA, imgB, flow, 0.5, 1, 10, 3, 5, 1.1, 0);

	//post process
	return flow;

}

void OpticalFlow::makecolorwheel(vector<Scalar> &colorwheel)
{
	int RY = 15;
	int YG = 6;
	int GC = 4;
	int CB = 11;
	int BM = 13;
	int MR = 6;

	int i;

	for (i = 0; i < RY; i++) colorwheel.push_back(Scalar(255, 255 * i / RY, 0));
	for (i = 0; i < YG; i++) colorwheel.push_back(Scalar(255 - 255 * i / YG, 255, 0));
	for (i = 0; i < GC; i++) colorwheel.push_back(Scalar(0, 255, 255 * i / GC));
	for (i = 0; i < CB; i++) colorwheel.push_back(Scalar(0, 255 - 255 * i / CB, 255));
	for (i = 0; i < BM; i++) colorwheel.push_back(Scalar(255 * i / BM, 0, 255));
	for (i = 0; i < MR; i++) colorwheel.push_back(Scalar(255, 0, 255 - 255 * i / MR));
}

void OpticalFlow::motionToColor(Mat flow, Mat &color)
{
	if (color.empty())
		color.create(flow.rows, flow.cols, CV_8UC3);

	static vector<Scalar> colorwheel; //Scalar r,g,b
	if (colorwheel.empty())
		makecolorwheel(colorwheel);

	// determine motion range:
	float maxrad = -1;

	// Find max flow to normalize fx and fy
	for (int i = 0; i < flow.rows; ++i)
	{
		for (int j = 0; j < flow.cols; ++j)
		{
			Vec2f flow_at_point = flow.at<Vec2f>(i, j);
			float fx = flow_at_point[0];
			float fy = flow_at_point[1];
			if ((fabs(fx) >  UNKNOWN_FLOW_THRESH) || (fabs(fy) > UNKNOWN_FLOW_THRESH))
				continue;
			float rad = sqrt(fx * fx + fy * fy);
			maxrad = maxrad > rad ? maxrad : rad;
		}
	}

	for (int i = 0; i < flow.rows; ++i)
	{
		for (int j = 0; j < flow.cols; ++j)
		{
			uchar *data = color.data + color.step[0] * i + color.step[1] * j;
			Vec2f flow_at_point = flow.at<Vec2f>(i, j);

			float fx = flow_at_point[0] / maxrad;
			float fy = flow_at_point[1] / maxrad;
			if ((fabs(fx) >  UNKNOWN_FLOW_THRESH) || (fabs(fy) > UNKNOWN_FLOW_THRESH))
			{
				data[0] = data[1] = data[2] = 0;
				continue;
			}
			float rad = sqrt(fx * fx + fy * fy);

			float angle = atan2(-fy, -fx) / CV_PI;
			float fk = (angle + 1.0) / 2.0 * (colorwheel.size() - 1);
			int k0 = (int)fk;
			int k1 = (k0 + 1) % colorwheel.size();
			float f = fk - k0;
			//f = 0; // uncomment to see original color wheel

			for (int b = 0; b < 3; b++)
			{
				float col0 = colorwheel[k0][b] / 255.0;
				float col1 = colorwheel[k1][b] / 255.0;
				float col = (1 - f) * col0 + f * col1;
				if (rad <= 1)
					col = 1 - rad * (1 - col); // increase saturation with radius
				else
					col *= .75; // out of range
				data[2 - b] = (int)(255.0 * col);
			}
		}
	}
}